// Package makeload is a load generation library for testing. See the README
// for usage information.
package makeload

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"sync"
	"sync/atomic"
	"time"
)

// Requester is an interface to modify how requests are made to the remote
// service. If supplied to the LoadGenerator struct, it will be used.
// Alternatively, LoadGenerator already supplies its own implementation.
type Requester interface {
	// Code to run when HTTP request delivery is made.
	Deliver(*url.URL) error
	// add status and possibly payload comparison functions to determine success
}

// Stats emcompasses the statistics for the requests already made.
type Stats struct {
	// Count of successes up to this point.
	successes atomic.Uint64
	// Count of failures up to this point.
	failures atomic.Uint64
}

func (s *Stats) Successes() uint64 {
	return s.successes.Load()
}

func (s *Stats) Failures() uint64 {
	return s.failures.Load()
}

// BatteryProperties are the list of properties common to each load generator.
type BatteryProperties struct {
	connCount atomic.Uint64
	connTotal atomic.Uint64

	// Concurrency is the number of concurrent request processors to make at a
	// time.
	concurrency uint64
	// SimultaneousConnections is the number of connections to maintain open at
	// any given time.
	simultaneousConnections uint64
	// URL is the url to connect to,
	url *url.URL
	// Ctx is a context which, if canceled, will stop load generation.
	ctx context.Context
	// Stats is the statistics generated by already processed load generation.
	stats Stats

	// Requester is the interface to HTTP requests.
	Requester

	client *http.Client
}

// NewBatteryProperties constructs a new BatteryProperties struct, which
// contains load generating parameters. Use this function to build it.
func NewBatteryProperties(ctx context.Context, concurrency, simultaneousConnections uint64, u *url.URL) *BatteryProperties {
	return &BatteryProperties{
		concurrency:             concurrency,
		simultaneousConnections: simultaneousConnections,
		url:                     u,
		ctx:                     ctx,
		client: &http.Client{
			Timeout: 0,
			Transport: &http.Transport{
				IdleConnTimeout:     0,
				MaxConnsPerHost:     int(simultaneousConnections),
				MaxIdleConns:        int(simultaneousConnections),
				MaxIdleConnsPerHost: int(simultaneousConnections),
			},
		},
	}
}

func (bp *BatteryProperties) Stats() *Stats {
	return &bp.stats
}

// Benchmarker is the main load generator struct for managing benchmarking.
// Call Spawn() on the result.
type Benchmarker struct {
	Properties *BatteryProperties
	Time       time.Duration
}

func NewBenchmarker(properties *BatteryProperties, duration time.Duration) *Benchmarker {
	return &Benchmarker{
		Properties: properties,
		Time:       duration,
	}
}

// Spawn launches the benchmarker. It will return an error if there was an
// error generating load. It does not error if there were issues making the
// individual HTTP requests. The Stats struct tracks the count of failures.
//
// To cancel load generation, cancel a passed context.
func (b *Benchmarker) Spawn() error {
	start := time.Now()
	return b.Properties.spawn(func(total uint64) bool { return start.Add(b.Time).Before(time.Now()) })
}

// LoadGenerator is the main load generator struct for managing load
// generation. One would construct this struct, filling out the proper
// parameters, and then would run Spawn() on the struct to apply load.
type LoadGenerator struct {
	Properties       *BatteryProperties
	TotalConnections uint64
}

func NewLoadGenerator(properties *BatteryProperties, total uint64) *LoadGenerator {
	return &LoadGenerator{
		Properties:       properties,
		TotalConnections: total,
	}
}

// Spawn launches the load generator. It will return an error if there was an
// error generating load. It does not error if there were issues making the
// individual HTTP requests. The Stats struct tracks the count of failures.
//
// To cancel load generation, cancel a passed context.
func (lg *LoadGenerator) Spawn() error {
	return lg.Properties.spawn(func(total uint64) bool { return lg.TotalConnections <= total })
}

func (p *BatteryProperties) spawn(cancelFunc func(uint64) bool) error {
	wg := &sync.WaitGroup{}
	wg.Add(int(p.concurrency))

	for i := uint64(0); i < p.concurrency; i++ {
		go makeRequests(wg, p, cancelFunc)
	}

	wg.Wait()
	return p.ctx.Err()
}

// this function performs the actual request delivery. it is run in multiple goroutines.
func makeRequests(wg *sync.WaitGroup, properties *BatteryProperties, cancelFunc func(uint64) bool) {
	defer func() {
		wg.Done()
	}()

	for {
		select {
		case <-properties.ctx.Done():
			return
		default:
		}

		if properties.simultaneousConnections <= properties.connCount.Load() {
			time.Sleep(10 * time.Millisecond) // make this tweakable
			continue
		}

		if cancelFunc(properties.connTotal.Load()) {
			return
		}

		val := properties.connCount.Add(1)
		properties.connTotal.Add(1)

		err := properties.Deliver(properties.url)

		for !properties.connCount.CompareAndSwap(val, val-1) {
			val = properties.connCount.Load()
		}

		if err != nil {
			properties.stats.failures.Add(1)
		} else {
			properties.stats.successes.Add(1)
		}
	}
}

// Deliver satisfies the Requester interface and encompasses basic delivery of
// a HTTP GET request.
func (p *BatteryProperties) Deliver(u *url.URL) error {
	resp, err := p.client.Get(u.String())
	if err != nil {
		return err
	}

	if resp.StatusCode != 200 {
		return errors.New("Non-200 status code")
	}

	return nil
}
